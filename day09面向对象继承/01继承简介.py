# -*- coding: utf-8 -*-
# 创建时间 : 2019/3/27 4:47
# 创建作者: binyang
# 创建目标: 继承简介


#继承指的是：
#一个类拥另一个类的资源的使用权
#一个类可以继承另一个类的属性和方法，

#类的区分
    #父类 超类 基类
    #子类 派生类 使用父类资源

#继承涉及的问题
    #1继承资源的权限 可使用的资源  
    #2继承资源的使用 多继承的时候资源选择 
    #2继承资源的覆盖 多继承的时候资源优先级的选择
    #4资源的累加     继承资源后，增加功能

#--------------------学习目标--------------------
#明确类的继承中优先查找对象  导入inspect 调用inspect.getmro 查看顺序  或者通过 类名.mro 查询，继承顺序
#


#---------------继承资源权限 公有 受保护 私有 ----------------
#属性和类的权限 
# 公有属性，
# 私有属性， _
# 受保护的属性 __

#1测试子类对父类的权限的继承
# 类同属性的权限  私有属性，和私有方法，都只能在类中使用，都不能直接访问
class Author_futher:
    #属性权限
    a = 1
    _b = 2
    __c = 3

    #方法权限
    def t1(self):
        print("t1")

    def _t2(self):
        print("t2")

    def __t3(self):
        print("t3")

    def __init__(self):  #内置方法
        print("init") 

class Test(Author_futher):
    def test(self):
        print(self.a)
        print(self._b)
        print(self.__c) 
    
        self.t1()
        self._t2()
        self.__t3()
        self.__init__()

p = Test()  #创建对象
p.t1()
p._t2()
# p.__t3()


#---------------继承资源调用的查找顺序 ----------------

#类的继承方式
    #单继承 只继承一个类 从下往上继承 从子类往父类查找
    #多继承  继承多个父类

        #python2.2之前 MRO原则
        #无重叠（属性，方法）的多继承  python2.2之前遵从深度优先，遵循单调原则，有限按照某个链条深度查找，如果没有换一路径 深度优先，先左后右
        #有重叠（属性，方法）的多继承  深度优先原则，但违背重写

        #python2.2 经典类，深度优先基础上添加广度优先，从左往右
        #无重叠多继承
        #有重叠多继承

        #python2.3-2.7版本中新式类和经典类并存
        #MRO 继承解析算法：
            #经典类：深度优先 （顶层不继承于object）
            #新式类： C3算法

        #python3 之后 只存在新式类 采用C3算法
        # C3算法 L(object) = object
        #L(子类（父类1，父类2）) = 子类 + merge（L（父类1），L(父类2)，（父类1，父类2））

        #merge算法
            #1第一个列表的第一个元素是后续列的第一个元素，或者它在后续列中没有再次出现




#-----------------------单继承示例-------------------------
class Amianl:
    pass


class Bird:
    pass

class People:
    pass

class Creature(Bird, People):  #多继承
    pass

print(Creature.__bases__)  #查看继承的基类

print(type(Creature))
print(Creature.__class__)

class Friend(Amianl):
    def __init__(self):
        pass
    
    pass






#--------------------资源覆盖 优先级高的继承中会优先调用同样属性的资源--------------------
# 优先访问先查找到的同名属性
print("-----验证优先查找覆盖验证-----")
class E(object):   #菱形继承
    #第3次继承

    age = 20
    pass

class F(E):
    #第一次继承
    pass

class G(E): #菱形继承
    #第2次继承
    age = 30 #同名属性，监测属性查找的继承的优先级

    pass

class H(F,G):
    pass

print("查看H类的继承顺序",H.mro())  #查看H类的继承顺序 [<class '__main__.H'>, <class '__main__.F'>, <class '__main__.G'>, <class '__main__.E'>, <class 'object'>]

print(H.age)   #30 由结知道，先查找到的同名属性，方法，先继承



#--------------------资源累加--------------------
#子类相比于父类可以由自己独特的方法和属性
    #属性：
        #类属性，实例属性

    #方法：
        #实例方法，类方法，静态方法

#--------------------Super 类 低优先级类的方法中调用高优先级类  --------------------
#super 是一个类，职业在新式类中有效
#作用：
    #起代理作用，沿着MRO链条，找到下一级别节点，找到对应的方法
    #方法：super（参数1(沿着参数1的mro链条)，参数2（寻找参数1的下一个节点））
    




        