# python多重继承新算法C3


## mro即 method resolution order (方法解释顺序)，主要用于在多继承时判断属性的路径(来自于哪个类)。

### 在python2.2版本中，算法基本思想是根据每个祖先类的继承结构，编译出一张列表，包括搜索到的类，按策略删除重复的。但是，在维护单调性方面失败过（顺序保存），所以从2.3版本，采用了新算法C3。

 

## 为什么采用C3算法
### C3算法最早被提出是用于Lisp的，应用在Python中是为了解决原来基于深度优先搜索算法不满足本地优先级，和单调性的问题。
### 本地优先级：指声明时父类的顺序，比如C(A,B)，如果访问C类对象属性时，应该根据声明顺序，优先查找A类，然后再查找B类。
### 单调性：如果在C的解析顺序中，A排在B的前面，那么在C的所有子类里，也必须满足这个顺序。

 

## C3算法
### 判断mro要先确定一个线性序列，然后查找路径由由序列中类的顺序决定。所以C3算法就是生成一个线性序列。
### 如果继承至一个基类:
### class B(A)
### 这时B的mro序列为[B,A]

## C3算法过程
## C3算法的本质就是Merge，不断地把mro�()函数返回的序列进行Merge，规则如下：
### 如果第一个序列的第一个元素，是后续序列的第一个元素，或者不在后续序列中再次出现，则将这个元素合并到最终的方法解析顺序序列中，并从当前操作的全部序列中删除。
### 如果不符合，则跳过此元素，查找下一个列表的第一个元素，重复1的判断规则


## 如果继承至多个基类 
## class B(A1,A2,A3 ...)
## 这时B的mro序列 mro(B) = [B] + merge(mro(A1), mro(A2), mro(A3) ..., [A1,A2,A3])
## merge操作就是C3算法的核心。
## 遍历执行merge操作的序列，如果一个序列的第一个元素，是其他序列中的第一个元素，或不在其他序列出现，则从所有执行merge操作序列中删除这个元素，合并到当前的mro中。
## merge操作后的序列，继续执行merge操作，直到merge操作的序列为空。
## 如果merge操作的序列无法为空，则说明不合法。
